# Journal: Deep-Dive on Key Projects

**Date**: 2026-01-08
**Session**: L1a Research
**Duration**: ~30 minutes

---

## Starting Point

L1 survey identified two projects requiring deep study before implementation:
1. **steipete/claude-code-mcp** - Claude Code as MCP server
2. **Kevinjulu/oh-my-opencode-CLI** - OpenCode plugin with Claude compat

Both directly relevant to our hub-spoke architecture.

---

## claude-code-mcp Analysis

### The "Agent in Agent" Pattern

This is elegant. The project exposes Claude Code as a single MCP tool that other agents can invoke. Key insight:

```
Host Agent (any model) → MCP → claude-code-mcp → Claude Code CLI
```

The host agent delegates complex file operations to Claude Code without needing to understand how Claude Code works internally.

### Permission Bypass Discovery

**This is gold.** Claude Code has a `--dangerously-skip-permissions` flag that:
1. User runs once manually, accepts terms
2. After that, flag can be used non-interactively
3. All permission prompts are bypassed

For our middleware, this means we can invoke Claude Code as a subprocess without it blocking on permission dialogs. Critical for invisible subprocess model.

### Working Directory Context

Must inject CWD into prompts:
```
"Your work folder is /path/to/project\n\n{actual task}"
```

Without this, Claude Code doesn't know where to operate. Simple but essential pattern.

---

## oh-my-opencode Analysis

### Multi-Model Teams

They went full enterprise with this. Agent teams:
- **Sisyphus** (Claude Opus 4.5) - main development
- **Oracle** (GPT 5.2) - debugging
- **Frontend** (Gemini 3) - UI/UX
- **Librarian** (Claude Sonnet) - documentation

Each model assigned to tasks matching its strengths. This validates our multi-model approach.

### Claude Compatibility Layer

They've already built what we're building - a layer that makes OpenCode behave like Claude Code:
- Commands, Agents, Skills, MCPs all work
- Hooks system (PreToolUse, PostToolUse, etc.)
- Subagent context inheritance

This is both exciting and concerning. Exciting because patterns are proven. Concerning because... do we need to build this ourselves?

### Async Subagents

Spawn agents that work in parallel:
```
Main Agent
    ├── Spawn Frontend (async) → working...
    ├── Spawn Backend (async) → working...
    └── Continue own work...

    [Results merged later]
```

This is exactly our "invisible subprocess" model, just with multiple subprocesses.

### Enforcement Mechanisms

Two clever features:
1. **Todo Continuation Enforcer** - agents can't quit until todos done
2. **Comment Checker** - validates code quality matches human output

The first one is brilliant. LLMs have a tendency to declare victory prematurely. Forcing completion is a good pattern.

---

## Strategic Realization

### The Difficult Question

Should we:
A. Use oh-my-opencode directly as our spoke?
B. Learn from it and build our own?
C. Hybrid approach?

### My Conclusion: Option C (Hybrid)

**Why not A (use directly)**:
- We want unique interaction modes (challenge/agree/collaborate/deduce)
- They don't have this
- Dependency on external project

**Why not B (build from scratch)**:
- Reinventing proven patterns
- More development time
- No advantage to building basic MCP/Claude compat ourselves

**Why C (hybrid)**:
- Adopt their *patterns*, not their *code*
- Build our interaction modes as novel contribution
- Use OpenCode HTTP API directly (simpler than full plugin)
- Incorporate enforcement mechanisms (todo continuation)

---

## Patterns We're Adopting

### From claude-code-mcp:
1. Permission bypass via `--dangerously-skip-permissions`
2. CWD context injection in prompts
3. Single tool interface (one `ask_agent()` tool)
4. One-shot execution model

### From oh-my-opencode:
1. Async subagent spawning pattern
2. Hooks for observability (PreToolUse, PostToolUse)
3. Todo continuation enforcement
4. Model-task matching (different models for different tasks)

---

## Architecture Refinement

Our middleware is now clearer:

```
Claude Code (Hub)
    │
    ├── x_agent_code middleware (MCP server)
    │       │
    │       ├── ask_agent() tool
    │       │       └── Spawns OpenCode subprocess
    │       │               └── Returns structured response
    │       │
    │       ├── Interaction Modes (NOVEL)
    │       │       └── challenge/agree/collaborate/deduce
    │       │
    │       └── Observability hooks
    │               └── PreToolUse, PostToolUse logging
    │
    └── OpenCode HTTP API (Spoke)
            └── GPT-5, Grok-4-fast, etc.
```

---

## Mood Check

Clarified and confident.

Deep-diving was the right call. We now know:
- Permission bypass works (tested by claude-code-mcp)
- Multi-model orchestration works (tested by oh-my-opencode)
- Our unique value is the interaction modes
- Implementation path is clearer

Ready to build.

---

## Next Steps

1. Start implementation skeleton
2. Implement permission bypass invocation
3. Implement basic ask_agent() tool
4. Add interaction mode selection
5. Add observability hooks

The research phase is essentially complete. Time to write code.
